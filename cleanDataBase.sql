-- BASIC CONFIGURATION

SET client_encoding = 'UTF8';

-- TABLES

CREATE TABLE coffee_variety (
    coffee_variety_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL
);

CREATE TABLE cultural_work_tasks (
    cultural_work_tasks_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cultural_works_id integer NOT NULL,
    plot_id integer NOT NULL,
    reminder_owner boolean NOT NULL,
    reminder_collaborator boolean NOT NULL,
    collaborator_user_id integer NOT NULL,
    owner_user_id integer NOT NULL,
    status_id integer,
    task_date date,
    created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE cultural_works (
    cultural_works_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL,
    description character varying(255)
);

CREATE TABLE farm (
    farm_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(100) NOT NULL,
    area numeric(10,2) NOT NULL,
    area_unit_id integer NOT NULL,
    status_id integer NOT NULL
);

CREATE TABLE flowering (
    flowering_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plot_id integer NOT NULL,
    flowering_date date NOT NULL,
    harvest_date date,
    status_id integer NOT NULL,
    flowering_type_id integer NOT NULL
);

CREATE TABLE flowering_type (
    flowering_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL
);

CREATE TABLE health_checks (
    health_checks_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    check_date date NOT NULL,
    recommendation_id integer NOT NULL,
    prediction character varying(150) NOT NULL,
    cultural_work_tasks_id integer NOT NULL,
    status_id integer DEFAULT 35 NOT NULL
);

CREATE TABLE invitation (
    invitation_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email character varying(150) NOT NULL,
    suggested_role character varying(50) NOT NULL,
    status_id integer DEFAULT 24 NOT NULL,
    farm_id integer NOT NULL,
    inviter_user_id integer NOT NULL,
    date timestamp NOT NULL
);

CREATE TABLE notification_type (
    notification_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL
);

CREATE TABLE notifications (
    notifications_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    message character varying(255),
    date timestamp NOT NULL,
    user_id integer NOT NULL,
    invitation_id integer,
    notification_type_id integer,
    farm_id integer,
    status_id integer
);

CREATE TABLE permission (
    permission_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    description character varying(200) NOT NULL,
    name character varying(50) UNIQUE
);

CREATE TABLE plot (
    plot_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(100) NOT NULL,
    longitude character varying(45),
    latitude character varying(45),
    altitude character varying(45),
    coffee_variety_id integer NOT NULL,
    farm_id integer NOT NULL,
    status_id integer
);

CREATE TABLE recommendation (
    recommendation_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    recommendation character varying(255) NOT NULL,
    name character varying(45) NOT NULL
);

CREATE TABLE role (
    role_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL UNIQUE
);

CREATE TABLE role_permission (
    role_id integer NOT NULL,
    permission_id integer NOT NULL,
    PRIMARY KEY (role_id, permission_id)
);

CREATE TABLE status (
    status_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(45) NOT NULL,
    status_type_id integer NOT NULL
);

CREATE TABLE status_type (
    status_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL
);

CREATE TABLE transaction (
    transaction_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plot_id integer NOT NULL,
    description character varying(50),
    transaction_type_id integer NOT NULL,
    transaction_date date NOT NULL,
    status_id integer NOT NULL,
    value bigint NOT NULL,
    transaction_category_id integer NOT NULL,
    creador_id integer
);

CREATE TABLE transaction_category (
    transaction_category_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL,
    transaction_type_id integer NOT NULL
);

CREATE TABLE transaction_type (
    transaction_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL
);

CREATE TABLE unit_of_measure (
    unit_of_measure_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL,
    abbreviation character varying(10) NOT NULL UNIQUE,
    unit_of_measure_type_id integer NOT NULL
);

CREATE TABLE unit_of_measure_type (
    unit_of_measure_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(50) NOT NULL
);

CREATE TABLE user_role_farm (
    user_role_farm_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_id integer NOT NULL,
    user_id integer NOT NULL,
    farm_id integer NOT NULL,
    status_id integer DEFAULT 22
);

CREATE TABLE users (
    user_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name character varying(100) NOT NULL,
    email character varying(150) NOT NULL UNIQUE,
    password_hash character varying(255) NOT NULL,
    verification_token character varying(255),
    session_token character varying(50),
    status_id integer NOT NULL,
    fcm_token character varying(255)
);

-- FOREIGN KEYS

ALTER TABLE ONLY cultural_work_tasks
    ADD CONSTRAINT fk_cultural_work_tasks_cultural_works FOREIGN KEY (cultural_works_id) REFERENCES cultural_works(cultural_works_id);

ALTER TABLE ONLY cultural_work_tasks
    ADD CONSTRAINT fk_cultural_work_tasks_plot FOREIGN KEY (plot_id) REFERENCES plot(plot_id);

ALTER TABLE ONLY cultural_work_tasks
    ADD CONSTRAINT fk_cultural_work_tasks_status FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_farm FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE ONLY farm
    ADD CONSTRAINT fk_farm_area_unit_id FOREIGN KEY (area_unit_id) REFERENCES unit_of_measure(unit_of_measure_id);

ALTER TABLE ONLY flowering
    ADD CONSTRAINT fk_flowering_plot_id FOREIGN KEY (plot_id) REFERENCES plot(plot_id) ON DELETE CASCADE;

ALTER TABLE ONLY flowering
    ADD CONSTRAINT fk_flowering_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY flowering
    ADD CONSTRAINT fk_flowering_type_id FOREIGN KEY (flowering_type_id) REFERENCES flowering_type(flowering_type_id);

ALTER TABLE ONLY health_checks
    ADD CONSTRAINT fk_health_checks_cultural_work_tasks FOREIGN KEY (cultural_work_tasks_id) REFERENCES cultural_work_tasks(cultural_work_tasks_id);

ALTER TABLE ONLY health_checks
    ADD CONSTRAINT fk_health_checks_recommendation FOREIGN KEY (recommendation_id) REFERENCES recommendation(recommendation_id);

ALTER TABLE ONLY health_checks
    ADD CONSTRAINT fk_health_checks_status FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY invitation
    ADD CONSTRAINT fk_invitation_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE ONLY invitation
    ADD CONSTRAINT fk_invitation_status FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY invitation
    ADD CONSTRAINT fk_invitation_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY invitation
    ADD CONSTRAINT fk_invitation_user FOREIGN KEY (inviter_user_id) REFERENCES users(user_id);

ALTER TABLE ONLY notifications
    ADD CONSTRAINT fk_notifications_notification_type_id FOREIGN KEY (notification_type_id) REFERENCES notification_type(notification_type_id) ON DELETE CASCADE;

ALTER TABLE ONLY notifications
    ADD CONSTRAINT fk_notifications_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY notifications
    ADD CONSTRAINT fk_notifications_user_id FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;

ALTER TABLE ONLY plot
    ADD CONSTRAINT fk_plot_coffee_variety_id FOREIGN KEY (coffee_variety_id) REFERENCES coffee_variety(coffee_variety_id);

ALTER TABLE ONLY plot
    ADD CONSTRAINT fk_plot_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE ONLY plot
    ADD CONSTRAINT fk_plot_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_role FOREIGN KEY (role_id) REFERENCES role(role_id) ON DELETE CASCADE;

ALTER TABLE ONLY role_permission
    ADD CONSTRAINT fk_role_permission_permission_id FOREIGN KEY (permission_id) REFERENCES permission(permission_id) ON DELETE CASCADE;

ALTER TABLE ONLY role_permission
    ADD CONSTRAINT fk_role_permission_role_id FOREIGN KEY (role_id) REFERENCES role(role_id) ON DELETE CASCADE;

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_status FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY plot
    ADD CONSTRAINT fk_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY status
    ADD CONSTRAINT fk_status_status_type_id FOREIGN KEY (status_type_id) REFERENCES status_type(status_type_id);

ALTER TABLE ONLY transaction
    ADD CONSTRAINT fk_transaction_plot_id FOREIGN KEY (plot_id) REFERENCES plot(plot_id) ON DELETE CASCADE;

ALTER TABLE ONLY transaction
    ADD CONSTRAINT fk_transaction_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY transaction
    ADD CONSTRAINT fk_transaction_transaction_category_id FOREIGN KEY (transaction_category_id) REFERENCES transaction_category(transaction_category_id);

ALTER TABLE ONLY transaction
    ADD CONSTRAINT fk_transaction_transaction_type_id FOREIGN KEY (transaction_type_id) REFERENCES transaction_type(transaction_type_id);

ALTER TABLE ONLY transaction_category
    ADD CONSTRAINT fk_transaction_type FOREIGN KEY (transaction_type_id) REFERENCES transaction_type(transaction_type_id) ON DELETE CASCADE;

ALTER TABLE ONLY unit_of_measure
    ADD CONSTRAINT fk_unit_of_measure_unit_of_measure_type_id FOREIGN KEY (unit_of_measure_type_id) REFERENCES unit_of_measure_type(unit_of_measure_type_id);

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_user_role_farm_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_user_role_farm_role_id FOREIGN KEY (role_id) REFERENCES role(role_id) ON DELETE CASCADE;

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_user_role_farm_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY user_role_farm
    ADD CONSTRAINT fk_user_role_farm_user_id FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;

ALTER TABLE ONLY users
    ADD CONSTRAINT fk_users_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notifications_farm_id_fkey FOREIGN KEY (farm_id) REFERENCES farm(farm_id);

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notifications_notification_type_id_fkey FOREIGN KEY (notification_type_id) REFERENCES notification_type(notification_type_id);

ALTER TABLE ONLY notifications
    ADD CONSTRAINT notifications_status_id_fkey FOREIGN KEY (status_id) REFERENCES status(status_id);

-- INDEXES

CREATE INDEX fk_flowering_plot1_idx ON flowering USING btree (plot_id);

CREATE INDEX fk_flowering_status1_idx ON flowering USING btree (status_id);

CREATE INDEX fk_invitation_farm1_idx ON invitation USING btree (farm_id);

CREATE INDEX fk_notifications_notification_type1_idx ON notifications USING btree (notification_type_id);

CREATE INDEX fk_notifications_user1_idx ON notifications USING btree (user_id);

CREATE INDEX fk_plot_coffee_variety1_idx ON plot USING btree (coffee_variety_id);

CREATE INDEX fk_plot_farm1_idx ON plot USING btree (farm_id);

CREATE INDEX fk_role_permissions_permissions1_idx ON role_permission USING btree (permission_id);

CREATE INDEX fk_role_permissions_roles1_idx ON role_permission USING btree (role_id);

CREATE INDEX fk_transaction_plot_id_idx ON transaction USING btree (plot_id);

CREATE INDEX fk_transaction_status_id_idx ON transaction USING btree (status_id);

CREATE INDEX fk_transaction_transaction_category_id_idx ON transaction USING btree (transaction_category_id);

CREATE INDEX fk_transaction_transaction_type_id_idx ON transaction USING btree (transaction_type_id);

CREATE INDEX fk_user_role_farm_farm1_idx ON user_role_farm USING btree (farm_id);

CREATE INDEX fk_user_role_farm_roles1_idx ON user_role_farm USING btree (role_id);

CREATE INDEX fk_user_role_farm_user1_idx ON user_role_farm USING btree (user_id);

CREATE INDEX idx_farm_area_unit_id ON farm USING btree (area_unit_id);

CREATE INDEX idx_status_status_type_id ON status USING btree (status_type_id);

CREATE INDEX idx_unit_of_measure_unit_of_measure_type_id ON unit_of_measure USING btree (unit_of_measure_type_id);

CREATE INDEX idx_users_status_id ON users USING btree (status_id);

CREATE INDEX ix_status_status_id ON status USING btree (status_id);

CREATE INDEX ix_status_type_status_type_id ON status_type USING btree (status_type_id);

CREATE INDEX ix_transaction_category_id ON transaction_category USING btree (transaction_category_id);

CREATE INDEX ix_transaction_type_id ON transaction_type USING btree (transaction_type_id);

-- FUNCTIONS

CREATE FUNCTION public.log_cultural_work_tasks_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
BEGIN
    -- Diagnóstico
    RAISE NOTICE 'Trigger activated for operation: %', TG_OP;

    -- Construir la consulta SQL según la operación
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.cultural_work_tasks_audit (cultural_work_tasks_id, cultural_works_id, plot_id, reminder_owner, reminder_collaborator, collaborator_user_id, owner_user_id, status_id, task_date, created_at, operation) VALUES ('
            || quote_literal(NEW.cultural_work_tasks_id) || ', '
            || quote_literal(NEW.cultural_works_id) || ', '
            || quote_literal(NEW.plot_id) || ', '
            || quote_literal(NEW.reminder_owner) || ', '
            || quote_literal(NEW.reminder_collaborator) || ', '
            || quote_literal(NEW.collaborator_user_id) || ', '
            || quote_literal(NEW.owner_user_id) || ', '
            || quote_literal(NEW.status_id) || ', '
            || quote_literal(NEW.task_date) || ', '
            || quote_literal(NEW.created_at) || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.cultural_work_tasks_audit (cultural_work_tasks_id, cultural_works_id, plot_id, reminder_owner, reminder_collaborator, collaborator_user_id, owner_user_id, status_id, task_date, created_at, operation) VALUES ('
            || quote_literal(NEW.cultural_work_tasks_id) || ', '
            || quote_literal(NEW.cultural_works_id) || ', '
            || quote_literal(NEW.plot_id) || ', '
            || quote_literal(NEW.reminder_owner) || ', '
            || quote_literal(NEW.reminder_collaborator) || ', '
            || quote_literal(NEW.collaborator_user_id) || ', '
            || quote_literal(NEW.owner_user_id) || ', '
            || quote_literal(NEW.status_id) || ', '
            || quote_literal(NEW.task_date) || ', '
            || quote_literal(NEW.created_at) || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.cultural_work_tasks_audit (cultural_work_tasks_id, cultural_works_id, plot_id, reminder_owner, reminder_collaborator, collaborator_user_id, owner_user_id, status_id, task_date, created_at, operation) VALUES ('
            || quote_literal(OLD.cultural_work_tasks_id) || ', '
            || quote_literal(OLD.cultural_works_id) || ', '
            || quote_literal(OLD.plot_id) || ', '
            || quote_literal(OLD.reminder_owner) || ', '
            || quote_literal(OLD.reminder_collaborator) || ', '
            || quote_literal(OLD.collaborator_user_id) || ', '
            || quote_literal(OLD.owner_user_id) || ', '
            || quote_literal(OLD.status_id) || ', '
            || quote_literal(OLD.task_date) || ', '
            || quote_literal(OLD.created_at) || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecución de la consulta
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_farm_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
    val_farm_id TEXT;
    val_name TEXT;
    val_area TEXT;
    val_area_unit_id TEXT;
    val_status_id TEXT;
BEGIN
    -- Diagnóstico
    RAISE NOTICE 'Trigger activated for operation: %', TG_OP;

    -- Asegurarse de que todos los valores sean válidos
    val_farm_id := COALESCE(quote_literal(NEW.farm_id), 'NULL');
    val_name := COALESCE(quote_literal(NEW.name), 'NULL');
    val_area := COALESCE(quote_literal(NEW.area), 'NULL');
    val_area_unit_id := COALESCE(quote_literal(NEW.area_unit_id), 'NULL');
    val_status_id := COALESCE(quote_literal(NEW.status_id), 'NULL');

    -- Construir la consulta SQL según la operación
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.farm_audit (farm_id, name, area, area_unit_id, status_id, operation) VALUES ('
            || val_farm_id || ', '
            || val_name || ', '
            || val_area || ', '
            || val_area_unit_id || ', '
            || val_status_id || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.farm_audit (farm_id, name, area, area_unit_id, status_id, operation) VALUES ('
            || val_farm_id || ', '
            || val_name || ', '
            || val_area || ', '
            || val_area_unit_id || ', '
            || val_status_id || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.farm_audit (farm_id, name, area, area_unit_id, status_id, operation) VALUES ('
            || COALESCE(quote_literal(OLD.farm_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.name), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.area), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.area_unit_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.status_id), 'NULL') || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecución de la consulta
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_health_checks_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
BEGIN
    -- Diagnóstico
    RAISE NOTICE 'Trigger activated for operation: %', TG_OP;

    -- Construir la consulta SQL según la operación
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.health_checks_audit (health_checks_id, check_date, recommendation_id, prediction, cultural_work_tasks_id, status_id, operation) VALUES ('
            || quote_literal(NEW.health_checks_id) || ', '
            || quote_literal(NEW.check_date) || ', '
            || quote_literal(NEW.recommendation_id) || ', '
            || quote_literal(NEW.prediction) || ', '
            || quote_literal(NEW.cultural_work_tasks_id) || ', '
            || quote_literal(NEW.status_id) || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.health_checks_audit (health_checks_id, check_date, recommendation_id, prediction, cultural_work_tasks_id, status_id, operation) VALUES ('
            || quote_literal(NEW.health_checks_id) || ', '
            || quote_literal(NEW.check_date) || ', '
            || quote_literal(NEW.recommendation_id) || ', '
            || quote_literal(NEW.prediction) || ', '
            || quote_literal(NEW.cultural_work_tasks_id) || ', '
            || quote_literal(NEW.status_id) || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.health_checks_audit (health_checks_id, check_date, recommendation_id, prediction, cultural_work_tasks_id, status_id, operation) VALUES ('
            || quote_literal(OLD.health_checks_id) || ', '
            || quote_literal(OLD.check_date) || ', '
            || quote_literal(OLD.recommendation_id) || ', '
            || quote_literal(OLD.prediction) || ', '
            || quote_literal(OLD.cultural_work_tasks_id) || ', '
            || quote_literal(OLD.status_id) || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecución de la consulta
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_flowering_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
BEGIN
    -- Construir la consulta SQL según la operación (INSERT, UPDATE, DELETE)
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.flowering_audit (flowering_id, plot_id, flowering_date, harvest_date, status_id, flowering_type_id, operation) VALUES ('
            || quote_literal(NEW.flowering_id) || ', '
            || quote_literal(NEW.plot_id) || ', '
            || quote_literal(NEW.flowering_date) || ', '
            || quote_literal(NEW.harvest_date) || ', '
            || quote_literal(NEW.status_id) || ', '
            || quote_literal(NEW.flowering_type_id) || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.flowering_audit (flowering_id, plot_id, flowering_date, harvest_date, status_id, flowering_type_id, operation) VALUES ('
            || quote_literal(NEW.flowering_id) || ', '
            || quote_literal(NEW.plot_id) || ', '
            || quote_literal(NEW.flowering_date) || ', '
            || quote_literal(NEW.harvest_date) || ', '
            || quote_literal(NEW.status_id) || ', '
            || quote_literal(NEW.flowering_type_id) || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.flowering_audit (flowering_id, plot_id, flowering_date, harvest_date, status_id, flowering_type_id, operation) VALUES ('
            || quote_literal(OLD.flowering_id) || ', '
            || quote_literal(OLD.plot_id) || ', '
            || quote_literal(OLD.flowering_date) || ', '
            || quote_literal(OLD.harvest_date) || ', '
            || quote_literal(OLD.status_id) || ', '
            || quote_literal(OLD.flowering_type_id) || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecutar la consulta (puedes usar dblink si es necesario, o ejecutar directamente si la tabla de auditoría está en la misma base de datos)
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_plot_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
    val_plot_id TEXT;
    val_name TEXT;
    val_longitude TEXT;
    val_latitude TEXT;
    val_altitude TEXT;
    val_coffee_variety_id TEXT;
    val_farm_id TEXT;
    val_status_id TEXT;
    val_user_id TEXT;
BEGIN
    -- Obtener el ID del usuario desde la sesión
    BEGIN
        val_user_id := current_setting('app.current_user', true);  -- Devuelve NULL si no se ha configurado
    EXCEPTION
        WHEN OTHERS THEN
            val_user_id := 'NULL';  -- Si no se configura el usuario, lo deja como NULL
    END;

    -- Obtener los valores de la fila afectada
    val_plot_id := COALESCE(quote_literal(NEW.plot_id), 'NULL');
    val_name := COALESCE(quote_literal(NEW.name), 'NULL');
    val_longitude := COALESCE(quote_literal(NEW.longitude), 'NULL');
    val_latitude := COALESCE(quote_literal(NEW.latitude), 'NULL');
    val_altitude := COALESCE(quote_literal(NEW.altitude), 'NULL');
    val_coffee_variety_id := COALESCE(quote_literal(NEW.coffee_variety_id), 'NULL');
    val_farm_id := COALESCE(quote_literal(NEW.farm_id), 'NULL');
    val_status_id := COALESCE(quote_literal(NEW.status_id), 'NULL');

    -- Construir la consulta según el tipo de operación (INSERT, UPDATE, DELETE)
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.plot_audit (plot_id, name, longitude, latitude, altitude, coffee_variety_id, farm_id, status_id, operation, user_id) VALUES ('
            || val_plot_id || ', '
            || val_name || ', '
            || val_longitude || ', '
            || val_latitude || ', '
            || val_altitude || ', '
            || val_coffee_variety_id || ', '
            || val_farm_id || ', '
            || val_status_id || ', ''I'', '
            || quote_literal(val_user_id) || ')';
    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.plot_audit (plot_id, name, longitude, latitude, altitude, coffee_variety_id, farm_id, status_id, operation, user_id) VALUES ('
            || val_plot_id || ', '
            || val_name || ', '
            || val_longitude || ', '
            || val_latitude || ', '
            || val_altitude || ', '
            || val_coffee_variety_id || ', '
            || val_farm_id || ', '
            || val_status_id || ', ''U'', '
            || quote_literal(val_user_id) || ')';
    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.plot_audit (plot_id, name, longitude, latitude, altitude, coffee_variety_id, farm_id, status_id, operation, user_id) VALUES ('
            || COALESCE(quote_literal(OLD.plot_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.name), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.longitude), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.latitude), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.altitude), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.coffee_variety_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.farm_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.status_id), 'NULL') || ', ''D'', '
            || quote_literal(val_user_id) || ')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecutar la consulta
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_role_permission_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
BEGIN
    -- Construir la consulta SQL
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.role_permission_audit (role_id, permission_id, operation) VALUES ('
            || quote_literal(NEW.role_id) || ', '
            || quote_literal(NEW.permission_id) || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.role_permission_audit (role_id, permission_id, operation) VALUES ('
            || quote_literal(NEW.role_id) || ', '
            || quote_literal(NEW.permission_id) || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.role_permission_audit (role_id, permission_id, operation) VALUES ('
            || quote_literal(OLD.role_id) || ', '
            || quote_literal(OLD.permission_id) || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecutar en base de datos externa
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_transaction_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
BEGIN
    -- Diagnóstico
    RAISE NOTICE 'Trigger activated for operation: %', TG_OP;

    -- Construir la consulta SQL según la operación
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.transaction_audit (transaction_id, plot_id, description, transaction_type_id, transaction_date, status_id, value, transaction_category_id, creador_id, operation) VALUES ('
            || quote_literal(NEW.transaction_id) || ', '
            || quote_literal(NEW.plot_id) || ', '
            || quote_literal(NEW.description) || ', '
            || quote_literal(NEW.transaction_type_id) || ', '
            || quote_literal(NEW.transaction_date) || ', '
            || quote_literal(NEW.status_id) || ', '
            || quote_literal(NEW.value) || ', '
            || quote_literal(NEW.transaction_category_id) || ', '
            || quote_literal(NEW.creador_id) || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.transaction_audit (transaction_id, plot_id, description, transaction_type_id, transaction_date, status_id, value, transaction_category_id, creador_id, operation) VALUES ('
            || quote_literal(NEW.transaction_id) || ', '
            || quote_literal(NEW.plot_id) || ', '
            || quote_literal(NEW.description) || ', '
            || quote_literal(NEW.transaction_type_id) || ', '
            || quote_literal(NEW.transaction_date) || ', '
            || quote_literal(NEW.status_id) || ', '
            || quote_literal(NEW.value) || ', '
            || quote_literal(NEW.transaction_category_id) || ', '
            || quote_literal(NEW.creador_id) || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.transaction_audit (transaction_id, plot_id, description, transaction_type_id, transaction_date, status_id, value, transaction_category_id, creador_id, operation) VALUES ('
            || quote_literal(OLD.transaction_id) || ', '
            || quote_literal(OLD.plot_id) || ', '
            || quote_literal(OLD.description) || ', '
            || quote_literal(OLD.transaction_type_id) || ', '
            || quote_literal(OLD.transaction_date) || ', '
            || quote_literal(OLD.status_id) || ', '
            || quote_literal(OLD.value) || ', '
            || quote_literal(OLD.transaction_category_id) || ', '
            || quote_literal(OLD.creador_id) || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecución de la consulta
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);
    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

CREATE FUNCTION public.log_user_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    sql TEXT;
    val_user_id TEXT;
    val_name TEXT;
    val_email TEXT;
    val_password_hash TEXT;
    val_verification_token TEXT;
    val_session_token TEXT;
    val_status_id TEXT;
    val_fcm_token TEXT;
BEGIN
    -- Diagnóstico
    RAISE NOTICE 'Trigger activated for operation: %', TG_OP;

    -- Asegurarse de que todos los valores sean válidos
    val_user_id := COALESCE(quote_literal(NEW.user_id), 'NULL');
    val_name := COALESCE(quote_literal(NEW.name), 'NULL');
    val_email := COALESCE(quote_literal(NEW.email), 'NULL');
    val_password_hash := COALESCE(quote_literal(NEW.password_hash), 'NULL');
    val_verification_token := COALESCE(quote_literal(NEW.verification_token), 'NULL');
    val_session_token := COALESCE(quote_literal(NEW.session_token), 'NULL');
    val_status_id := COALESCE(quote_literal(NEW.status_id), 'NULL');
    val_fcm_token := COALESCE(quote_literal(NEW.fcm_token), 'NULL');

    -- Construir la consulta SQL según la operación
    IF TG_OP = 'INSERT' THEN
        sql := 'INSERT INTO audit.users_audit (user_id, name, email, password_hash, verification_token, session_token, status_id, fcm_token, operation) VALUES ('
            || val_user_id || ', '
            || val_name || ', '
            || val_email || ', '
            || val_password_hash || ', '
            || val_verification_token || ', '
            || val_session_token || ', '
            || val_status_id || ', '
            || val_fcm_token || ', ''I'')';

    ELSIF TG_OP = 'UPDATE' THEN
        sql := 'INSERT INTO audit.users_audit (user_id, name, email, password_hash, verification_token, session_token, status_id, fcm_token, operation) VALUES ('
            || val_user_id || ', '
            || val_name || ', '
            || val_email || ', '
            || val_password_hash || ', '
            || val_verification_token || ', '
            || val_session_token || ', '
            || val_status_id || ', '
            || val_fcm_token || ', ''U'')';

    ELSIF TG_OP = 'DELETE' THEN
        sql := 'INSERT INTO audit.users_audit (user_id, name, email, password_hash, verification_token, session_token, status_id, fcm_token, operation) VALUES ('
            || COALESCE(quote_literal(OLD.user_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.name), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.email), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.password_hash), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.verification_token), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.session_token), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.status_id), 'NULL') || ', '
            || COALESCE(quote_literal(OLD.fcm_token), 'NULL') || ', ''D'')';
    END IF;

    -- Diagnóstico de la consulta construida
    RAISE NOTICE 'Executing SQL: %', sql;

    -- Ejecución de la consulta
    BEGIN
        PERFORM dblink_exec('host=junction.proxy.rlwy.net port=15674 dbname=postgres user=postgres password=NtEdGgDlBFTGqdvtxSJDPFUuVILcBoVb', sql);

    EXCEPTION
        WHEN OTHERS THEN
            RAISE NOTICE 'Error en dblink_exec: %', SQLERRM;
    END;

    RETURN NEW;
END;
$$;

-- TRIGGERS

CREATE TRIGGER cultural_work_tasks_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON cultural_work_tasks FOR EACH ROW EXECUTE FUNCTION log_cultural_work_tasks_changes();

CREATE TRIGGER farm_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON farm FOR EACH ROW EXECUTE FUNCTION log_farm_changes();

CREATE TRIGGER health_checks_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON health_checks FOR EACH ROW EXECUTE FUNCTION log_health_checks_changes();

CREATE TRIGGER log_flowering_changes AFTER INSERT OR DELETE OR UPDATE ON flowering FOR EACH ROW EXECUTE FUNCTION log_flowering_changes();

CREATE TRIGGER plot_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON plot FOR EACH ROW EXECUTE FUNCTION log_plot_changes();

CREATE TRIGGER role_permission_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON role_permission FOR EACH ROW EXECUTE FUNCTION log_role_permission_changes();

CREATE TRIGGER transaction_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON transaction FOR EACH ROW EXECUTE FUNCTION log_transaction_changes();

CREATE TRIGGER users_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON users FOR EACH ROW EXECUTE FUNCTION log_user_changes();