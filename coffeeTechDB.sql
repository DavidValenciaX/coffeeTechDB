-- BASIC CONFIGURATION

SET client_encoding = 'UTF8';

-- EXTENSIONS

CREATE EXTENSION pg_stat_statements;

BEGIN;

-- TABLES

CREATE TABLE coffee_variety (
    coffee_variety_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE cultural_works (
    cultural_works_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT
);

CREATE TABLE cultural_work_tasks (
    cultural_work_tasks_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cultural_works_id integer NOT NULL,
    plot_id integer NOT NULL,
    reminder_owner boolean NOT NULL,
    reminder_collaborator boolean NOT NULL,
    collaborator_user_id integer NOT NULL,
    owner_user_id integer NOT NULL,
    status_id integer NOT NULL,
    task_date date,
    created_at timestamp DEFAULT CURRENT_TIMESTAMP NOT NULL
);

CREATE TABLE flowering (
    flowering_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plot_id integer NOT NULL,
    flowering_date date NOT NULL,
    harvest_date date,
    status_id integer NOT NULL,
    flowering_type_id integer NOT NULL
);

CREATE TABLE flowering_type (
    flowering_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE health_checks (
    health_checks_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    check_date date NOT NULL,
    recommendation_id integer NOT NULL,
    prediction VARCHAR(150) NOT NULL,
    cultural_work_tasks_id integer NOT NULL,
    status_id integer DEFAULT 35 NOT NULL
);

CREATE TABLE users (
    user_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    email VARCHAR(150) NOT NULL UNIQUE,
    password_hash VARCHAR(255) NOT NULL,
    verification_token VARCHAR(255),
    session_token VARCHAR(255),
    status_id integer NOT NULL,
    fcm_token VARCHAR(255)
);

CREATE TABLE invitation (
    invitation_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    email VARCHAR(150) NOT NULL,
    suggested_role VARCHAR(255) NOT NULL,
    status_id integer DEFAULT 24 NOT NULL,
    farm_id integer NOT NULL,
    inviter_user_id integer NOT NULL,
    date timestamp NOT NULL
);

CREATE TABLE notification_type (
    notification_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE notifications (
    notifications_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    message VARCHAR(255),
    date timestamp NOT NULL,
    user_id integer NOT NULL,
    invitation_id integer,
    notification_type_id integer,
    farm_id integer NOT NULL,
    status_id integer NOT NULL
);

CREATE TABLE permission (
    permission_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    description VARCHAR(200) NOT NULL,
    name VARCHAR(255) UNIQUE
);

CREATE TABLE plot (
    plot_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    longitude NUMERIC(11, 8) CHECK (longitude BETWEEN -180 AND 180),
    latitude NUMERIC(11, 8) CHECK (latitude BETWEEN -90 AND 90),
    altitude NUMERIC(10, 2),
    coffee_variety_id integer NOT NULL,
    farm_id integer NOT NULL,
    status_id integer NOT NULL
);

CREATE TABLE recommendation (
    recommendation_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    recommendation VARCHAR(255) NOT NULL,
    name VARCHAR(45) NOT NULL
);

CREATE TABLE role (
    role_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL UNIQUE
);

CREATE TABLE role_permission (
    role_id integer NOT NULL,
    permission_id integer NOT NULL,
    PRIMARY KEY (role_id, permission_id)
);

CREATE TABLE status_type (
    status_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE status (
    status_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(45) NOT NULL,
    status_type_id integer NOT NULL
);

CREATE TABLE transaction (
    transaction_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    plot_id integer NOT NULL,
    description VARCHAR(255),
    transaction_type_id integer NOT NULL,
    transaction_date date NOT NULL,
    status_id integer NOT NULL,
    value numeric(15, 2) NOT NULL,
    transaction_category_id integer NOT NULL,
    creador_id integer NOT NULL
);

CREATE TABLE transaction_type (
    transaction_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE transaction_category (
    transaction_category_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    transaction_type_id integer NOT NULL
);

CREATE TABLE unit_of_measure_type (
    unit_of_measure_type_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL
);

CREATE TABLE unit_of_measure (
    unit_of_measure_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    abbreviation VARCHAR(10) NOT NULL UNIQUE,
    unit_of_measure_type_id integer NOT NULL
);

CREATE TABLE farm (
    farm_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    area numeric(10,2) NOT NULL,
    area_unit_id integer NOT NULL,
    status_id integer NOT NULL
);

CREATE TABLE user_role_farm (
    user_role_farm_id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    role_id integer NOT NULL,
    user_id integer NOT NULL,
    farm_id integer NOT NULL,
    status_id integer DEFAULT 22 NOT NULL,
    UNIQUE(user_id, role_id, farm_id)
);

-- FOREIGN KEYS

ALTER TABLE cultural_work_tasks
    ADD CONSTRAINT fk_cultural_work_tasks_cultural_works FOREIGN KEY (cultural_works_id) REFERENCES cultural_works(cultural_works_id);

ALTER TABLE cultural_work_tasks
    ADD CONSTRAINT fk_cultural_work_tasks_plot FOREIGN KEY (plot_id) REFERENCES plot(plot_id);

ALTER TABLE cultural_work_tasks
    ADD CONSTRAINT fk_cultural_work_tasks_status FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE cultural_work_tasks 
    ADD CONSTRAINT fk_cultural_work_tasks_collaborator_user FOREIGN KEY (collaborator_user_id) REFERENCES users(user_id);

ALTER TABLE cultural_work_tasks 
    ADD CONSTRAINT fk_cultural_work_tasks_owner_user FOREIGN KEY (owner_user_id) REFERENCES users(user_id);

ALTER TABLE farm
    ADD CONSTRAINT fk_farm_area_unit_id FOREIGN KEY (area_unit_id) REFERENCES unit_of_measure(unit_of_measure_id);

ALTER TABLE flowering
    ADD CONSTRAINT fk_flowering_plot_id FOREIGN KEY (plot_id) REFERENCES plot(plot_id) ON DELETE CASCADE;

ALTER TABLE flowering
    ADD CONSTRAINT fk_flowering_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE flowering
    ADD CONSTRAINT fk_flowering_type_id FOREIGN KEY (flowering_type_id) REFERENCES flowering_type(flowering_type_id);

ALTER TABLE health_checks
    ADD CONSTRAINT fk_health_checks_cultural_work_tasks FOREIGN KEY (cultural_work_tasks_id) REFERENCES cultural_work_tasks(cultural_work_tasks_id) ON DELETE CASCADE;

ALTER TABLE health_checks
    ADD CONSTRAINT fk_health_checks_recommendation FOREIGN KEY (recommendation_id) REFERENCES recommendation(recommendation_id);

ALTER TABLE health_checks
    ADD CONSTRAINT fk_health_checks_status FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE invitation
    ADD CONSTRAINT fk_invitation_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE invitation
    ADD CONSTRAINT fk_invitation_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE invitation
    ADD CONSTRAINT fk_invitation_user FOREIGN KEY (inviter_user_id) REFERENCES users(user_id);

ALTER TABLE notifications
    ADD CONSTRAINT fk_notifications_notification_type_id FOREIGN KEY (notification_type_id) REFERENCES notification_type(notification_type_id) ON DELETE CASCADE;

ALTER TABLE notifications
    ADD CONSTRAINT fk_notifications_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE notifications
    ADD CONSTRAINT fk_notifications_user_id FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;

ALTER TABLE notifications
    ADD CONSTRAINT fk_notifications_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id);

ALTER TABLE notifications 
    ADD CONSTRAINT fk_notifications_invitation_id FOREIGN KEY (invitation_id) REFERENCES invitation(invitation_id);

ALTER TABLE plot
    ADD CONSTRAINT fk_plot_coffee_variety_id FOREIGN KEY (coffee_variety_id) REFERENCES coffee_variety(coffee_variety_id);

ALTER TABLE plot
    ADD CONSTRAINT fk_plot_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE plot
    ADD CONSTRAINT fk_plot_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE role_permission
    ADD CONSTRAINT fk_role_permission_permission_id FOREIGN KEY (permission_id) REFERENCES permission(permission_id) ON DELETE CASCADE;

ALTER TABLE role_permission
    ADD CONSTRAINT fk_role_permission_role_id FOREIGN KEY (role_id) REFERENCES role(role_id) ON DELETE CASCADE;

ALTER TABLE status
    ADD CONSTRAINT fk_status_status_type_id FOREIGN KEY (status_type_id) REFERENCES status_type(status_type_id);

ALTER TABLE transaction
    ADD CONSTRAINT fk_transaction_plot_id FOREIGN KEY (plot_id) REFERENCES plot(plot_id) ON DELETE CASCADE;

ALTER TABLE transaction
    ADD CONSTRAINT fk_transaction_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE transaction
    ADD CONSTRAINT fk_transaction_transaction_category_id FOREIGN KEY (transaction_category_id) REFERENCES transaction_category(transaction_category_id);

ALTER TABLE transaction
    ADD CONSTRAINT fk_transaction_transaction_type_id FOREIGN KEY (transaction_type_id) REFERENCES transaction_type(transaction_type_id);

ALTER TABLE transaction 
    ADD CONSTRAINT fk_transaction_creador FOREIGN KEY (creador_id) REFERENCES users(user_id);

ALTER TABLE transaction_category
    ADD CONSTRAINT fk_transaction_type FOREIGN KEY (transaction_type_id) REFERENCES transaction_type(transaction_type_id) ON DELETE CASCADE;

ALTER TABLE unit_of_measure
    ADD CONSTRAINT fk_unit_of_measure_unit_of_measure_type_id FOREIGN KEY (unit_of_measure_type_id) REFERENCES unit_of_measure_type(unit_of_measure_type_id);

ALTER TABLE user_role_farm
    ADD CONSTRAINT fk_user_role_farm_farm_id FOREIGN KEY (farm_id) REFERENCES farm(farm_id) ON DELETE CASCADE;

ALTER TABLE user_role_farm
    ADD CONSTRAINT fk_user_role_farm_role_id FOREIGN KEY (role_id) REFERENCES role(role_id) ON DELETE CASCADE;

ALTER TABLE user_role_farm
    ADD CONSTRAINT fk_user_role_farm_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

ALTER TABLE user_role_farm
    ADD CONSTRAINT fk_user_role_farm_user_id FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE;

ALTER TABLE users
    ADD CONSTRAINT fk_users_status_id FOREIGN KEY (status_id) REFERENCES status(status_id);

-- Create audit schema if it doesn't exist
CREATE SCHEMA IF NOT EXISTS audit;

-- Create an ENUM type for audit operations
CREATE TYPE audit.operation_type AS ENUM ('INSERT', 'UPDATE', 'DELETE');

-- Audit table for cultural_work_tasks
CREATE TABLE IF NOT EXISTS audit.cultural_work_tasks_audit (
    audit_id SERIAL PRIMARY KEY,
    cultural_work_tasks_id INTEGER,
    cultural_works_id INTEGER,
    plot_id INTEGER,
    reminder_owner BOOLEAN,
    reminder_collaborator BOOLEAN,
    collaborator_user_id INTEGER,
    owner_user_id INTEGER,
    status_id INTEGER,
    task_date DATE,
    created_at TIMESTAMP,
    operation audit.operation_type NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for farm
CREATE TABLE IF NOT EXISTS audit.farm_audit (
    audit_id SERIAL PRIMARY KEY,
    farm_id INTEGER,
    name VARCHAR(255),
    area NUMERIC(10,2),
    area_unit_id INTEGER,
    status_id INTEGER,
    operation audit.operation_type NOT NULL,
    old_name VARCHAR(255),
    old_area NUMERIC(10,2),
    old_area_unit_id INTEGER,
    old_status_id INTEGER,
    modified_by_user_id INTEGER,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for health_checks
CREATE TABLE IF NOT EXISTS audit.health_checks_audit (
    audit_id SERIAL PRIMARY KEY,
    health_checks_id INTEGER,
    check_date DATE,
    recommendation_id INTEGER,
    prediction VARCHAR(150),
    cultural_work_tasks_id INTEGER,
    status_id INTEGER,
    operation audit.operation_type NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for flowering
CREATE TABLE IF NOT EXISTS audit.flowering_audit (
    audit_id SERIAL PRIMARY KEY,
    flowering_id INTEGER,
    plot_id INTEGER,
    flowering_date DATE,
    harvest_date DATE,
    status_id INTEGER,
    flowering_type_id INTEGER,
    operation audit.operation_type NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for plot
CREATE TABLE IF NOT EXISTS audit.plot_audit (
    audit_id SERIAL PRIMARY KEY,
    plot_id INTEGER,
    name VARCHAR(255),
    longitude NUMERIC(11, 8),
    latitude NUMERIC(11, 8),
    altitude NUMERIC(10, 2),
    coffee_variety_id INTEGER,
    farm_id INTEGER,
    status_id INTEGER,
    operation audit.operation_type NOT NULL,
    old_name VARCHAR(255),
    old_longitude NUMERIC(11, 8),
    old_latitude NUMERIC(11, 8),
    old_altitude NUMERIC(10, 2),
    old_coffee_variety_id INTEGER,
    old_farm_id INTEGER,
    old_status_id INTEGER,
    modified_by_user_id INTEGER,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for role_permission
CREATE TABLE IF NOT EXISTS audit.role_permission_audit (
    audit_id SERIAL PRIMARY KEY,
    role_id INTEGER,
    permission_id INTEGER,
    operation audit.operation_type NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for transaction
CREATE TABLE IF NOT EXISTS audit.transaction_audit (
    audit_id SERIAL PRIMARY KEY,
    transaction_id INTEGER,
    plot_id INTEGER,
    description varchar(255),
    transaction_type_id INTEGER,
    transaction_date DATE,
    status_id INTEGER,
    value numeric(15,2),
    transaction_category_id INTEGER,
    creador_id INTEGER,
    operation audit.operation_type NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Audit table for users
CREATE TABLE IF NOT EXISTS audit.users_audit (
    audit_id SERIAL PRIMARY KEY,
    user_id INTEGER,
    name VARCHAR(255),
    email VARCHAR(150),
    password_hash VARCHAR(255),
    verification_token VARCHAR(255),
    session_token varchar(255),
    status_id INTEGER,
    fcm_token VARCHAR(255),
    operation audit.operation_type NOT NULL,
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- FUNCTIONS

CREATE OR REPLACE FUNCTION log_cultural_work_tasks_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log based on operation type
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.cultural_work_tasks_audit (
            cultural_work_tasks_id, cultural_works_id, plot_id, 
            reminder_owner, reminder_collaborator, collaborator_user_id, 
            owner_user_id, status_id, task_date, created_at, operation
        ) VALUES (
            NEW.cultural_work_tasks_id, NEW.cultural_works_id, NEW.plot_id,
            NEW.reminder_owner, NEW.reminder_collaborator, NEW.collaborator_user_id,
            NEW.owner_user_id, NEW.status_id, NEW.task_date, NEW.created_at, 'INSERT'
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.cultural_work_tasks_audit (
            cultural_work_tasks_id, cultural_works_id, plot_id, 
            reminder_owner, reminder_collaborator, collaborator_user_id, 
            owner_user_id, status_id, task_date, created_at, operation
        ) VALUES (
            NEW.cultural_work_tasks_id, NEW.cultural_works_id, NEW.plot_id,
            NEW.reminder_owner, NEW.reminder_collaborator, NEW.collaborator_user_id,
            NEW.owner_user_id, NEW.status_id, NEW.task_date, NEW.created_at, 'UPDATE'
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.cultural_work_tasks_audit (
            cultural_work_tasks_id, cultural_works_id, plot_id, 
            reminder_owner, reminder_collaborator, collaborator_user_id, 
            owner_user_id, status_id, task_date, created_at, operation
        ) VALUES (
            OLD.cultural_work_tasks_id, OLD.cultural_works_id, OLD.plot_id,
            OLD.reminder_owner, OLD.reminder_collaborator, OLD.collaborator_user_id,
            OLD.owner_user_id, OLD.status_id, OLD.task_date, OLD.created_at, 'DELETE'
        );
    END IF;
    
    RETURN NEW;
END;
$$;

-- Función mejorada para auditar cambios en farm
CREATE OR REPLACE FUNCTION log_farm_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    val_user_id INTEGER;
BEGIN
    -- Obtener el ID del usuario actual desde la sesión si está disponible
    BEGIN
        val_user_id := NULLIF(current_setting('app.current_user', true), '')::INTEGER;
    EXCEPTION
        WHEN OTHERS THEN
            val_user_id := NULL;
    END;

    -- Registrar según el tipo de operación
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.farm_audit (
            farm_id, name, area, area_unit_id, status_id, operation, modified_by_user_id
        ) VALUES (
            NEW.farm_id, NEW.name, NEW.area, NEW.area_unit_id, NEW.status_id, 'INSERT', val_user_id
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.farm_audit (
            farm_id, name, area, area_unit_id, status_id, 
            old_name, old_area, old_area_unit_id, old_status_id,
            operation, modified_by_user_id
        ) VALUES (
            NEW.farm_id, NEW.name, NEW.area, NEW.area_unit_id, NEW.status_id,
            OLD.name, OLD.area, OLD.area_unit_id, OLD.status_id,
            'UPDATE', val_user_id
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.farm_audit (
            farm_id, name, area, area_unit_id, status_id, operation, modified_by_user_id
        ) VALUES (
            OLD.farm_id, OLD.name, OLD.area, OLD.area_unit_id, OLD.status_id, 'DELETE', val_user_id
        );
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION log_health_checks_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log based on operation type
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.health_checks_audit (
            health_checks_id, check_date, recommendation_id, prediction, 
            cultural_work_tasks_id, status_id, operation
        ) VALUES (
            NEW.health_checks_id, NEW.check_date, NEW.recommendation_id, NEW.prediction,
            NEW.cultural_work_tasks_id, NEW.status_id, 'INSERT'
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.health_checks_audit (
            health_checks_id, check_date, recommendation_id, prediction, 
            cultural_work_tasks_id, status_id, operation
        ) VALUES (
            NEW.health_checks_id, NEW.check_date, NEW.recommendation_id, NEW.prediction,
            NEW.cultural_work_tasks_id, NEW.status_id, 'UPDATE'
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.health_checks_audit (
            health_checks_id, check_date, recommendation_id, prediction, 
            cultural_work_tasks_id, status_id, operation
        ) VALUES (
            OLD.health_checks_id, OLD.check_date, OLD.recommendation_id, OLD.prediction,
            OLD.cultural_work_tasks_id, OLD.status_id, 'DELETE'
        );
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION log_flowering_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log based on operation type
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.flowering_audit (
            flowering_id, plot_id, flowering_date, harvest_date, 
            status_id, flowering_type_id, operation
        ) VALUES (
            NEW.flowering_id, NEW.plot_id, NEW.flowering_date, NEW.harvest_date,
            NEW.status_id, NEW.flowering_type_id, 'INSERT'
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.flowering_audit (
            flowering_id, plot_id, flowering_date, harvest_date, 
            status_id, flowering_type_id, operation
        ) VALUES (
            NEW.flowering_id, NEW.plot_id, NEW.flowering_date, NEW.harvest_date,
            NEW.status_id, NEW.flowering_type_id, 'UPDATE'
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.flowering_audit (
            flowering_id, plot_id, flowering_date, harvest_date, 
            status_id, flowering_type_id, operation
        ) VALUES (
            OLD.flowering_id, OLD.plot_id, OLD.flowering_date, OLD.harvest_date,
            OLD.status_id, OLD.flowering_type_id, 'DELETE'
        );
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION log_plot_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
    val_user_id INTEGER;
BEGIN
    -- Obtener el ID del usuario actual desde la sesión si está disponible
    BEGIN
        val_user_id := NULLIF(current_setting('app.current_user', true), '')::INTEGER;
    EXCEPTION
        WHEN OTHERS THEN
            val_user_id := NULL;
    END;

    -- Registrar según el tipo de operación
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.plot_audit (
            plot_id, name, longitude, latitude, altitude,
            coffee_variety_id, farm_id, status_id, operation, modified_by_user_id
        ) VALUES (
            NEW.plot_id, NEW.name, NEW.longitude, NEW.latitude, NEW.altitude,
            NEW.coffee_variety_id, NEW.farm_id, NEW.status_id, 'INSERT', val_user_id
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.plot_audit (
            plot_id, name, longitude, latitude, altitude,
            coffee_variety_id, farm_id, status_id,
            old_name, old_longitude, old_latitude, old_altitude,
            old_coffee_variety_id, old_farm_id, old_status_id,
            operation, modified_by_user_id
        ) VALUES (
            NEW.plot_id, NEW.name, NEW.longitude, NEW.latitude, NEW.altitude,
            NEW.coffee_variety_id, NEW.farm_id, NEW.status_id,
            OLD.name, OLD.longitude, OLD.latitude, OLD.altitude,
            OLD.coffee_variety_id, OLD.farm_id, OLD.status_id,
            'UPDATE', val_user_id
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.plot_audit (
            plot_id, name, longitude, latitude, altitude,
            coffee_variety_id, farm_id, status_id, operation, modified_by_user_id
        ) VALUES (
            OLD.plot_id, OLD.name, OLD.longitude, OLD.latitude, OLD.altitude,
            OLD.coffee_variety_id, OLD.farm_id, OLD.status_id, 'DELETE', val_user_id
        );
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION log_role_permission_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log based on operation type
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.role_permission_audit (
            role_id, permission_id, operation
        ) VALUES (
            NEW.role_id, NEW.permission_id, 'INSERT'
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.role_permission_audit (
            role_id, permission_id, operation
        ) VALUES (
            NEW.role_id, NEW.permission_id, 'UPDATE'
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.role_permission_audit (
            role_id, permission_id, operation
        ) VALUES (
            OLD.role_id, OLD.permission_id, 'DELETE'
        );
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION log_transaction_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log based on operation type
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.transaction_audit (
            transaction_id, plot_id, description, transaction_type_id,
            transaction_date, status_id, value, transaction_category_id,
            creador_id, operation
        ) VALUES (
            NEW.transaction_id, NEW.plot_id, NEW.description, NEW.transaction_type_id,
            NEW.transaction_date, NEW.status_id, NEW.value, NEW.transaction_category_id,
            NEW.creador_id, 'INSERT'
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.transaction_audit (
            transaction_id, plot_id, description, transaction_type_id,
            transaction_date, status_id, value, transaction_category_id,
            creador_id, operation
        ) VALUES (
            NEW.transaction_id, NEW.plot_id, NEW.description, NEW.transaction_type_id,
            NEW.transaction_date, NEW.status_id, NEW.value, NEW.transaction_category_id,
            NEW.creador_id, 'UPDATE'
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.transaction_audit (
            transaction_id, plot_id, description, transaction_type_id,
            transaction_date, status_id, value, transaction_category_id,
            creador_id, operation
        ) VALUES (
            OLD.transaction_id, OLD.plot_id, OLD.description, OLD.transaction_type_id,
            OLD.transaction_date, OLD.status_id, OLD.value, OLD.transaction_category_id,
            OLD.creador_id, 'DELETE'
        );
    END IF;
    
    RETURN NEW;
END;
$$;

CREATE OR REPLACE FUNCTION log_user_changes() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
    -- Log based on operation type
    IF TG_OP = 'INSERT' THEN
        INSERT INTO audit.users_audit (
            user_id, name, email, password_hash, verification_token,
            session_token, status_id, fcm_token, operation
        ) VALUES (
            NEW.user_id, NEW.name, NEW.email, NEW.password_hash, NEW.verification_token,
            NEW.session_token, NEW.status_id, NEW.fcm_token, 'INSERT'
        );
    ELSIF TG_OP = 'UPDATE' THEN
        INSERT INTO audit.users_audit (
            user_id, name, email, password_hash, verification_token,
            session_token, status_id, fcm_token, operation
        ) VALUES (
            NEW.user_id, NEW.name, NEW.email, NEW.password_hash, NEW.verification_token,
            NEW.session_token, NEW.status_id, NEW.fcm_token, 'UPDATE'
        );
    ELSIF TG_OP = 'DELETE' THEN
        INSERT INTO audit.users_audit (
            user_id, name, email, password_hash, verification_token,
            session_token, status_id, fcm_token, operation
        ) VALUES (
            OLD.user_id, OLD.name, OLD.email, OLD.password_hash, OLD.verification_token,
            OLD.session_token, OLD.status_id, OLD.fcm_token, 'DELETE'
        );
    END IF;
    
    RETURN NEW;
END;
$$;

-- TRIGGERS

CREATE TRIGGER cultural_work_tasks_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON cultural_work_tasks FOR EACH ROW EXECUTE FUNCTION log_cultural_work_tasks_changes();

CREATE TRIGGER farm_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON farm FOR EACH ROW EXECUTE FUNCTION log_farm_changes();

CREATE TRIGGER health_checks_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON health_checks FOR EACH ROW EXECUTE FUNCTION log_health_checks_changes();

CREATE TRIGGER log_flowering_changes AFTER INSERT OR DELETE OR UPDATE ON flowering FOR EACH ROW EXECUTE FUNCTION log_flowering_changes();

CREATE TRIGGER plot_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON plot FOR EACH ROW EXECUTE FUNCTION log_plot_changes();

CREATE TRIGGER role_permission_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON role_permission FOR EACH ROW EXECUTE FUNCTION log_role_permission_changes();

CREATE TRIGGER transaction_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON transaction FOR EACH ROW EXECUTE FUNCTION log_transaction_changes();

CREATE TRIGGER users_audit_trigger AFTER INSERT OR DELETE OR UPDATE ON users FOR EACH ROW EXECUTE FUNCTION log_user_changes();

-- INDEXES

CREATE INDEX idx_cultural_work_tasks_collaborator_user ON cultural_work_tasks (collaborator_user_id);

CREATE INDEX idx_cultural_work_tasks_owner_user ON cultural_work_tasks (owner_user_id);

CREATE INDEX idx_flowering_plot ON flowering (plot_id);

CREATE INDEX idx_flowering_status ON flowering (status_id);

CREATE INDEX idx_invitation_farm ON invitation (farm_id);

CREATE INDEX idx_notifications_notification_type ON notifications (notification_type_id);

CREATE INDEX idx_notifications_user ON notifications (user_id);

CREATE INDEX idx_plot_coffee_variety ON plot (coffee_variety_id);

CREATE INDEX idx_plot_farm ON plot (farm_id);

CREATE INDEX idx_role_permissions_permissions ON role_permission (permission_id);

CREATE INDEX idx_role_permissions_roles ON role_permission (role_id);

CREATE INDEX idx_transaction_plot_id ON transaction (plot_id);

CREATE INDEX idx_transaction_status_id ON transaction (status_id);

CREATE INDEX idx_transaction_transaction_category_id ON transaction (transaction_category_id);

CREATE INDEX idx_transaction_transaction_type_id ON transaction (transaction_type_id);

CREATE INDEX idx_user_role_farm_farm ON user_role_farm (farm_id);

CREATE INDEX idx_user_role_farm_roles ON user_role_farm (role_id);

CREATE INDEX idx_user_role_farm_user ON user_role_farm (user_id);

CREATE INDEX idx_farm_area_unit_id ON farm (area_unit_id);

CREATE INDEX idx_status_status_type_id ON status (status_type_id);

CREATE INDEX idx_unit_of_measure_unit_of_measure_type_id ON unit_of_measure (unit_of_measure_type_id);

CREATE INDEX idx_users_status_id ON users (status_id);

CREATE INDEX idx_status_status_id ON status (status_id);

CREATE INDEX idx_status_type_status_type_id ON status_type (status_type_id);

CREATE INDEX idx_transaction_category_id ON transaction_category (transaction_category_id);

CREATE INDEX idx_transaction_type_id ON transaction_type (transaction_type_id);

CREATE INDEX idx_invitation_inviter_user_id ON invitation (inviter_user_id);

CREATE INDEX idx_health_checks_status_id ON health_checks (status_id);

CREATE INDEX idx_health_checks_recommendation_id ON health_checks (recommendation_id);

CREATE INDEX idx_health_checks_cultural_work_tasks_id ON health_checks (cultural_work_tasks_id);

CREATE INDEX idx_cultural_work_tasks_plot_id ON cultural_work_tasks (plot_id);

CREATE INDEX idx_cultural_work_tasks_cultural_works_id ON cultural_work_tasks (cultural_works_id);

CREATE INDEX idx_notifications_invitation_id ON notifications (invitation_id);

CREATE INDEX idx_notifications_farm_id ON notifications (farm_id);

CREATE INDEX idx_notifications_status_id ON notifications (status_id);

CREATE INDEX idx_transaction_creador_id ON transaction (creador_id);

CREATE INDEX idx_flowering_flowering_type_id ON flowering (flowering_type_id);

CREATE INDEX idx_farm_status_id ON farm (status_id);

CREATE INDEX idx_users_email ON users (email);

CREATE INDEX idx_transaction_category_transaction_type_id ON transaction_category (transaction_type_id);

CREATE INDEX idx_cultural_work_tasks_plot_status ON cultural_work_tasks (plot_id, status_id);

CREATE INDEX idx_transaction_plot_date ON transaction (plot_id, transaction_date);

CREATE INDEX idx_user_role_farm_user_role ON user_role_farm (user_id, role_id);

-- Confirmar la transacción si todo va bien
COMMIT;